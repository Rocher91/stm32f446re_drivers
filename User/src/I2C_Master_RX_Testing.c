#include "stm32f446xx.h"
#include "stm32f446xx_Gpio_Driver.h"
#include "stm32f446xx_I2C_Driver.h"
#include <stdio.h>
#include <string.h>

void I2C_GPIOInits(void);
void I2CInits(void);
void delay(void);

#define MY_ADDR         0x61
#define SLAVE_ADDR      0x68

/*
    PB6 -> SCL
    PB9 -> SDA
*/

I2C_Handle_t I2C1Handle;

//DATA
uint8_t rcv_buff[] = "";

void delay(void)
{
	int i = 0;
	
	for( i=0; i< 100000; i++);
}


void I2C_GPIOInits(void)
{   
    //Page 58 Datasheet stm32f446RE

    GPIO_Handle_t I2CPins = {                                 
                                .GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_ALTERNATE,
                                .GPIO_PinConfig.GPIO_PinAltFuncMode = GPIO_AF4,
                                .GPIO_PinConfig.GPIO_PinOPType      = GPIO_OPEN_DRAIN,
                                .GPIO_PinConfig.GPIO_PinPupdControl = GPIO_NPUPD,
                                .GPIO_PinConfig.GPIO_PinSpeed       = GPIO_FAST_SPEED,
                                .pGPIOx                             = GPIOB  
                            };
		
		GPIO_Handle_t UserButton = {                                 
                                .GPIO_PinConfig.GPIO_PinMode        = GPIO_MODE_IT_FALLING,
                                .GPIO_PinConfig.GPIO_PinOPType      = GPIO_OPEN_DRAIN,
                                .GPIO_PinConfig.GPIO_PinPupdControl = GPIO_NPUPD,
                                .GPIO_PinConfig.GPIO_PinSpeed       = GPIO_HIGH_SPEED,
                                .pGPIOx                             = NUCLEO_PORT_BUTTON  
                            };											
														
		UserButton.GPIO_PinConfig.GPIO_PinNumber 			= NUCLEO_PIN_BUTTON;
		GPIO_PerCLKControl( NUCLEO_PORT_BUTTON, ENABLE );
    GPIO_Init(&UserButton);
													

    I2CPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_6;
    GPIO_PerCLKControl( GPIOB, ENABLE );
    GPIO_Init(&I2CPins);

    I2CPins.GPIO_PinConfig.GPIO_PinNumber = GPIO_PIN_7;
    GPIO_PerCLKControl( GPIOB, ENABLE );
    GPIO_Init(&I2CPins);

}

void I2CInits(void)
{
    I2C1Handle.pI2Cx                        = I2C1;
    I2C1Handle.I2C_Config.I2C_ACK_Control   = I2C_ACK_ENABLE;
    I2C1Handle.I2C_Config.I2C_DeviceAddress = MY_ADDR;
    I2C1Handle.I2C_Config.I2C_FM_DutyCycle  = I2C_FM_DUTY_2;
    I2C1Handle.I2C_Config.I2C_SCL_Speed     = I2C_SCL_SPEED_SM;

    I2C_Init(&I2C1Handle);

}

void I2C_EV_IRQHandling( I2C_Handle_t *pI2CHandle )
{
	//Interrupt handling for both master and slave mode of a device
	
	uint32_t temp1 = 0;
	uint32_t temp2 = 0;
	uint32_t temp3 = 0;
	
	temp1 = pI2CHandle->pI2Cx->CR[1] & ( 1 << I2C_CR2_ITEVTEN );
	temp2 = pI2CHandle->pI2Cx->CR[1] & ( 1 << I2C_CR2_ITBUFEN );
	
	temp3 = pI2CHandle->pI2Cx->SR[0] & ( 1 << I2C_SR1_SB );
	
	//1. Handle for interrupt generated by SB event
	// Note: SB flag is only applicable in Master mode
	
	if ( temp1 && temp3 )
	{
			//THe interrup is generated because of SB event
			//This block will not be executed in slave mode because for slave SB is always zero
			//In this block lets executed the address phase
		if( pI2CHandle->TxRxState == I2C_BUSY_IN_TX)
		{
			I2C_ExecuteAddressPhaseWrite(pI2CHandle->pI2Cx,pI2CHandle->DevAddress);
		}
		else 
		{
			I2C_ExecuteAddressPhaseRead(pI2CHandle->pI2Cx,pI2CHandle->DevAddress);
		}	
	}
	
	temp3 = pI2CHandle->pI2Cx->SR[0] & ( 1 << I2C_SR1_ADDR );
	
	//2. Handle for interrupt generated by ADDR event
	//Note: When master mode: Address is sent
	// When Slave mode: Address matched with own address
	
	if ( temp1 && temp3 )
	{
			//ADDR flag is set
			I2C_ClearADDRFlag(pI2CHandle->pI2Cx);
	}
	
	temp3 = pI2CHandle->pI2Cx->SR[0] & ( 1 << I2C_SR1_BTF );
	
	//3. Handle for interrupt generated by BTF (Byte Transfer Finished) event
	
	if ( temp1 && temp3 )
	{
			//BTF flag is set
		if (pI2CHandle->TxRxState == I2C_BUSY_IN_TX)
		{
			// make sure that Txe is also set
			if ( pI2CHandle->pI2Cx->SR[0] & ( 1 << I2C_SR1_TxE) )
			{
				//BTF, TXE = 1
				//1. generate STOP condition
				if (pI2CHandle->Sr == I2C_DISABLE_SR)
				{
					I2C_GenerateStopCondition( pI2CHandle->pI2Cx );
				}
				
				//2. reset all the member elements of the handle structure.
				I2C_CloseSendData(pI2CHandle);
				
				//3. notify the application about transmission complete
				I2C_ApplicationEventCallback(pI2CHandle,I2C_EV_TX_CMPLTE);
			}
		}
		else if (pI2CHandle->TxRxState == I2C_BUSY_IN_RX)
		{
			if ( pI2CHandle->pI2Cx->SR[0] & ( 1 << I2C_SR1_RxNE) )
			{
				//BTF, RxNE = 1
				;
			}
			
		}
			
	}
	
	temp3 = pI2CHandle->pI2Cx->SR[0] & ( 1 << I2C_SR1_STOPF );
	
	//4. Handle for interrupt generated by STOPF event
	//NOte: Stop detection flag is applicable only slave mode. For master rhis fï¿½ag
	
	if ( temp1 && temp3 )
	{
			//STOPF flag is set
		// Clear the STOPF read SR1 2) Write to CR1
		pI2CHandle->pI2Cx->CR[0] |= 0x0000;
		
		//Notify the app that Stop is detected
		I2C_ApplicationEventCallback(pI2CHandle,I2C_EV_STOP);
		
	}
	
	temp3 = pI2CHandle->pI2Cx->SR[0] & ( 1 << I2C_SR1_TxE );
	
	//5. Handle for interrupt generated by TxE event
	
	if ( temp1 && temp2 && temp3 )
	{
			if( pI2CHandle->pI2Cx->SR[1] & ( 1 << I2C_SR2_MSL))
			{
				//TxE flag is set
				// We have to do the data transmission
				if( pI2CHandle->TxRxState == I2C_BUSY_IN_TX)
				{
					I2C_MasterHandleTxEInterrupt( pI2CHandle );
				}	
			}	
	}
	
	temp3 = pI2CHandle->pI2Cx->SR[0] & ( 1 << I2C_SR1_RxNE );

	//6. Handle for interrupt generated by RxNE event
	
	if ( temp1 && temp2 && temp3 )
	{	
			//Check device Mode
			if( pI2CHandle->pI2Cx->SR[1] & ( 1 << I2C_SR2_MSL))
			{
					//The device is master
					//RxNE flag is set
					if ( pI2CHandle->TxRxState == I2C_BUSY_IN_RX)
					{
						I2C_MasterHandleRxNEInterrupt(pI2CHandle);
					}
			}
	}

}



void I2C_CloseReceiveData(I2C_Handle_t *pI2CHandle)
{
		//Implement the code to disable ITBUFEN Control Bit
		pI2CHandle->pI2Cx->CR[1] &= ~( 1 << I2C_CR2_ITBUFEN);
	
		//Implement the code to disable ITBUFEN Control Bit
		pI2CHandle->pI2Cx->CR[1] &= ~( 1 << I2C_CR2_ITEVTEN);
	
		pI2CHandle->TxRxState = I2C_READY;
		pI2CHandle->pRxBuffer = NULL;
		pI2CHandle->RxLen 		= 0;
		pI2CHandle->TxLen 		= 0;
		pI2CHandle->RxSize 		= 0;
		
		if(pI2CHandle->I2C_Config.I2C_ACK_Control == I2C_ACK_ENABLE)
		{
			I2C_ManageAcking(pI2CHandle->pI2Cx,ENABLE);
		}

}

void I2C_CloseSendData(I2C_Handle_t *pI2CHandle)
{
		//Implement the code to disable ITBUFEN Control Bit
		pI2CHandle->pI2Cx->CR[1] &= ~( 1 << I2C_CR2_ITBUFEN);
	
		//Implement the code to disable ITBUFEN Control Bit
		pI2CHandle->pI2Cx->CR[1] &= ~( 1 << I2C_CR2_ITEVTEN);
	
		pI2CHandle->TxRxState = I2C_READY;
		pI2CHandle->pRxBuffer = NULL;
		pI2CHandle->RxLen 		= 0;
		pI2CHandle->RxSize 		= 0;
}


static void I2C_MasterHandleTxEInterrupt( I2C_Handle_t *pI2CHandle )
{
	if( pI2CHandle->TxLen > 0 )
					{
						//1. Load the data in to DR.
						pI2CHandle->pI2Cx->DR = *(pI2CHandle->pTxBuffer);
						
						//2. decrement the TxLen
						pI2CHandle->TxLen--;
						
						//3. Increment the buffer address
						pI2CHandle->pTxBuffer++;
					}
}
static void I2C_MasterHandleRxNEInterrupt( I2C_Handle_t *pI2CHandle )
{
	
			//We have to do the data reception
				if( pI2CHandle->RxLen == 1)
				{
					*pI2CHandle->pRxBuffer = pI2CHandle->pI2Cx->DR;
					pI2CHandle->RxLen--;
				}
				else if( pI2CHandle->RxLen > 1)
				{
					if( pI2CHandle->RxLen == 2)
					{
						//Clear the ack bit
						I2C_ManageAcking(pI2CHandle->pI2Cx,DISABLE);
					}
					
					//read DR
					*pI2CHandle->pRxBuffer = pI2CHandle->pI2Cx->DR;
					pI2CHandle->pRxBuffer++;
					pI2CHandle->RxLen--;
				}
				
				if( pI2CHandle->RxLen == 0)
				{
					//close the I2C data reception and notify the application.
					
					//1. Generate the stop condition.
					if (pI2CHandle->Sr == I2C_DISABLE_SR)
					{
						I2C_GenerateStopCondition( pI2CHandle->pI2Cx );
						
					}
					//2. Close the I2C Rx.
					
					I2C_CloseReceiveData(pI2CHandle);
					//3. Notify the application.
					I2C_ApplicationEventCallback(pI2CHandle,I2C_EV_RX_CMPLTE);
				}

}
/*void I2C_ER_IRQHandling( I2C_Handle_t *pI2CHandle )
{

}
*/
int main(){
	
  uint8_t commandCode = 0;
  uint8_t len  = 0;

  //I2C Pin Inits
	I2C_GPIOInits();

	//I2C peripheral Configuration
	I2CInits();

	//Enable the I2C peripheral
	I2C_PeripheralControl(I2C1,I2C_ACK_ENABLE);

  // ack bit is made 1 after PE = 1
  I2C_ManageAcking(I2C1,ENABLE);
	
	while(1)
	{
		//wait for Button press
		while(!GPIO_ReadFromInputPin( NUCLEO_PORT_BUTTON, NUCLEO_PIN_LED ));
		
		//to avoid button de-bouncing related issues 200ms of delay
		delay();
        
		commandCode = 0x51;

		//Send data
		I2C_MasterSendData(&I2C1Handle,&commandCode,1,SLAVE_ADDR,I2C_ENABLE_SR);

		//Read Data
		I2C_MasterReceiveData(&I2C1Handle,&len,1,SLAVE_ADDR,I2C_ENABLE_SR);

		commandCode = 0x52;

		//Send data
		I2C_MasterSendData(&I2C1Handle,&commandCode,1,SLAVE_ADDR,I2C_ENABLE_SR);

		//Read Data
		I2C_MasterReceiveData(&I2C1Handle,&rcv_buff,len,SLAVE_ADDR,I2C_DISABLE_SR);
		
		rcv_buff[len+1] = '\0';
		
	}
}



